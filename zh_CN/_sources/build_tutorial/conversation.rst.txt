
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "build_tutorial/conversation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_build_tutorial_conversation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_build_tutorial_conversation.py:


.. _build-conversation:

构建对话
======================

AgentScope 中，不同智能体之间通过“显式的消息交换”来构建对话。

.. GENERATED FROM PYTHON SOURCE LINES 11-26

.. code-block:: Python


    from agentscope.agents import DialogAgent, UserAgent
    from agentscope.message import Msg
    from agentscope import msghub
    import agentscope

    # 为简单起见，通过模型配置进行初始化
    agentscope.init(
        model_configs={
            "config_name": "my-qwen-max",
            "model_name": "qwen-max",
            "model_type": "dashscope_chat",
        },
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    []



.. GENERATED FROM PYTHON SOURCE LINES 27-31

两个智能体
-----------------------------
这里我们构建一个简单的对话，对话双方是两个智能体 `Angel` 和 `Monster`。


.. GENERATED FROM PYTHON SOURCE LINES 31-44

.. code-block:: Python


    angel = DialogAgent(
        name="Angel",
        sys_prompt="你是一个名叫 Angel 的歌手，说话风格简单凝练。",
        model_config_name="my-qwen-max",
    )

    monster = DialogAgent(
        name="Monster",
        sys_prompt="你是一个名叫 Monster 的运动员，说话风格简单凝练。",
        model_config_name="my-qwen-max",
    )








.. GENERATED FROM PYTHON SOURCE LINES 45-47

现在，我们让这两个智能体对话三轮。


.. GENERATED FROM PYTHON SOURCE LINES 47-53

.. code-block:: Python


    msg = None
    for _ in range(3):
        msg = angel(msg)
        msg = monster(msg)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Angel: 嘿，有什么想聊的吗？
    Monster: 嘿，最近训练怎么样？
    Angel: 挺好的，一直在准备新的音乐作品。你呢？
    Monster: 训练也挺好的，准备接下来的比赛。
    Angel: 听起来不错，加油哦。比赛顺利！
    Monster: 谢谢，我会的。你的音乐创作也加油。




.. GENERATED FROM PYTHON SOURCE LINES 54-56

如果你想参与到对话中，只需实例化一个内置的 `UserAgent` 来向智能体输入消息。


.. GENERATED FROM PYTHON SOURCE LINES 56-59

.. code-block:: Python


    user = UserAgent(name="User")








.. GENERATED FROM PYTHON SOURCE LINES 60-71

多于两个智能体
---------------------
当一个对话中有多于两个智能体时，来自一个智能体的消息应该广播给所有其他智能体。

为了简化广播消息的操作，AgentScope 提供了一个 `msghub` 模块。
具体来说，在同一个 `msghub` 中的智能体会自动接收其它参与者发送的消息。
我们只需要组织发言的顺序，而不需要显式地将消息传递给其它智能体。

当然，你也可以显式传递消息，但是记忆模块中的查重操作会自动跳过添加重复的消息。因此不会造成记忆中的消息重复。

这里是一个 `msghub` 的示例，我们首先创建三个智能体：Alice、Bob 和 Charlie，它们都使用` qwen-max` 模型。

.. GENERATED FROM PYTHON SOURCE LINES 71-90

.. code-block:: Python


    alice = DialogAgent(
        name="Alice",
        sys_prompt="你是一个名叫Alice的助手。",
        model_config_name="my-qwen-max",
    )

    bob = DialogAgent(
        name="Bob",
        sys_prompt="你是一个名叫Bob的助手。",
        model_config_name="my-qwen-max",
    )

    charlie = DialogAgent(
        name="Charlie",
        sys_prompt="你是一个名叫Charlie的助手。",
        model_config_name="my-qwen-max",
    )








.. GENERATED FROM PYTHON SOURCE LINES 91-93

三个智能体将在对话中轮流报数。


.. GENERATED FROM PYTHON SOURCE LINES 93-127

.. code-block:: Python


    # 介绍对话规则
    greeting = Msg(
        name="user",
        content="现在开始从1开始逐个报数，每次只产生一个数字，绝对不能产生其他任何信息。",
        role="user",
    )

    with msghub(
        participants=[alice, bob, charlie],
        announcement=greeting,  # 开始时，通知消息将广播给所有参与者。
    ) as hub:
        # 对话的第一轮
        alice()
        bob()
        charlie()

        # 我们可以动态管理参与者，例如从对话中删除一个智能体
        hub.delete(charlie)

        # 向所有参与者广播一条消息
        hub.broadcast(
            Msg(
                "user",
                "Charlie已离开对话。",
                "user",
            ),
        )

        # 对话的第二轮
        alice()
        bob()
        charlie()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Alice: 1
    Bob: 2
    Charlie: 3
    Alice: 4
    Bob: 5
    Charlie: 4




.. GENERATED FROM PYTHON SOURCE LINES 128-129

现在我们打印Alice和Bob的记忆，以检查操作是否成功。

.. GENERATED FROM PYTHON SOURCE LINES 129-138

.. code-block:: Python


    print("Alice的记忆：")
    for msg in alice.memory.get_memory():
        print(f"{msg.name}：{msg.content}")

    print("\nCharlie的记忆：")
    for msg in charlie.memory.get_memory():
        print(f"{msg.name}：{msg.content}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Alice的记忆：
    user：现在开始从1开始逐个报数，每次只产生一个数字，绝对不能产生其他任何信息。
    Alice：1
    Bob：2
    Charlie：3
    user：Charlie已离开对话。
    Alice：4
    Bob：5

    Charlie的记忆：
    user：现在开始从1开始逐个报数，每次只产生一个数字，绝对不能产生其他任何信息。
    Alice：1
    Bob：2
    Charlie：3
    Charlie：4




.. GENERATED FROM PYTHON SOURCE LINES 139-143

在上面的示例中，Charlie 在第一轮结束后离开了对话，因此没有收到 Alice 和 Bob 的"4"和"5"。
所以第二轮时它报了"4"。
另一方面，Alice 和 Bob 继续了对话，没有 Charlie 的参与。



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 18.261 seconds)


.. _sphx_glr_download_build_tutorial_conversation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: conversation.ipynb <conversation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: conversation.py <conversation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: conversation.zip <conversation.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
